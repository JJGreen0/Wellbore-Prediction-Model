<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drilling Simulation with Predictive Graph</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            background-color: #f0f2f5;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars from layout shifts */
        }
        #simulation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff;
            padding: 20px;
            margin: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 98vw;
            height: 95vh;
        }
        h1 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            flex-shrink: 0;
        }
        #main-content {
            display: flex;
            width: 100%;
            height: 100%;
            gap: 20px;
        }
        #wellbore-container, #graph-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
        }
        #wellbore-container {
            flex: 0 0 320px; /* Fixed width for the wellbore */
        }
        #graph-container {
            flex-grow: 1; /* Graph takes remaining space */
        }
        h2 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: #444;
        }
        canvas {
            border: 2px solid #333;
        }
        #wellboreCanvas {
            background-color: #e8dcc5; /* Sandstone */
        }
        #graphCanvas {
            background-color: #fdfdfd;
        }
        #controls {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 400px;
            flex-shrink: 0;
        }
        #depth-slider {
            width: 80%;
        }
        button {
            padding: 8px 18px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        #info-display {
            font-size: 1em;
            font-weight: bold;
            color: #555;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
</head>
<body>

<div id="simulation-container">
    <h1>Drilling Simulation & Analysis</h1>
    <div id="main-content">
        <div id="wellbore-container">
            <h2>Wellbore View</h2>
            <canvas id="wellboreCanvas"></canvas>
        </div>
        <div id="graph-container">
            <h2>Density vs. Depth</h2>
            <canvas id="graphCanvas"></canvas>
        </div>
    </div>
    <div id="controls">
        <div id="info-display">Current Depth: 0.0 m</div>
        <button id="play-pause-btn">Play</button>
        <label for="depth-slider">Manual Depth Control</label>
        <input type="range" id="depth-slider" min="0" max="3000" step="0.1" value="0">
    </div>
</div>

<script>
    // --- Configuration ---
    let MAX_DEPTH = 0;
    const LOOKAHEAD_DISTANCE = 50;
    let MAX_GRAPH_DEPTH = 0; // Graph needs to see further
    const DRILL_SPEED = 50;
    const BASE_DENSITY = 2200;

    // --- DOM Elements ---
    const wellboreCanvas = document.getElementById('wellboreCanvas');
    const wellboreCtx = wellboreCanvas.getContext('2d');
    const graphCanvas = document.getElementById('graphCanvas');
    const graphCtx = graphCanvas.getContext('2d');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const depthSlider = document.getElementById('depth-slider');
    const infoDisplay = document.getElementById('info-display');

    // --- Simulation State ---
    let rockData = [];
    let predictedData = [];
    let minDensity, maxDensity;
    let currentDepth = 0;
    let isDrilling = false;
    let animationFrameId;
    let particles = [];
    let depthData = [];
    let startDepth = 0;

    async function loadRockData() {
        const response = await fetch('WLC_MUD_LOG_INTERPOLATED.csv');
        const csvText = await response.text();
        const parsed = Papa.parse(csvText, {header: true, dynamicTyping: true}).data;
        startDepth = parseFloat(parsed[0]['Unnamed: 0']) || 0;
        parsed.forEach(row => {
            const depth = parseFloat(row['Unnamed: 0']);
            const gr = parseFloat(row['GR']);
            if (isFinite(depth) && isFinite(gr)) {
                depthData.push(depth - startDepth);
                rockData.push(gr);
            }
        });

        // Load pre-computed predictions for depth + 50 m
        const predResp = await fetch('predictions_50m.csv');
        const predText = await predResp.text();
        const predParsed = Papa.parse(predText, {header: true, dynamicTyping: true}).data;
        const predMap = new Map();
        predParsed.forEach(row => {
            const d = parseFloat(row['Depth']);
            const p = parseFloat(row['Predicted_GR']);
            if (isFinite(d) && isFinite(p)) {
                predMap.set(d - startDepth, p);
            }
        });
        depthData.forEach(d => {
            const val = predMap.get(d);
            predictedData.push(val !== undefined ? val : null);
        });

        MAX_DEPTH = depthData[depthData.length - 1];
        MAX_GRAPH_DEPTH = MAX_DEPTH + LOOKAHEAD_DISTANCE;
        const allDensities = rockData.concat(predictedData.filter(v => v !== null));
        minDensity = Math.min(...allDensities) - 5;
        maxDensity = Math.max(...allDensities) + 5;
    }

    function predictDensity(depth) {
        const idx = findIndexForDepth(depth);
        const pred = predictedData[idx];
        if (pred === null || pred === undefined) {
            return getActualDensity(depth);
        }
        return pred;
    }

    function findIndexForDepth(depth) {
        let low = 0, high = depthData.length - 1;
        while (low < high) {
            const mid = Math.floor((low + high) / 2);
            if (depthData[mid] < depth) low = mid + 1;
            else high = mid;
        }
        return low;
    }

    function getActualDensity(depth) {
        const idx = findIndexForDepth(depth);
        return rockData[idx] || BASE_DENSITY;
    }


    // --- 2. DRAWING & VISUALIZATION ---

    function drawWellbore() {
        wellboreCtx.clearRect(0, 0, wellboreCanvas.width, wellboreCanvas.height);
        const holeY = (currentDepth / MAX_DEPTH) * wellboreCanvas.height;
        const wellboreCenterX = wellboreCanvas.width / 2;
        wellboreCtx.fillStyle = '#3a352d';
        wellboreCtx.fillRect(wellboreCenterX - 11, 0, 22, holeY);
        
        particles.forEach(p => {
            p.x += p.vx; p.y += p.vy; p.lifespan--;
            wellboreCtx.fillStyle = p.color; wellboreCtx.globalAlpha = p.lifespan / 50;
            wellboreCtx.fillRect(p.x, p.y, p.size, p.size);
        });
        wellboreCtx.globalAlpha = 1.0;
        particles = particles.filter(p => p.lifespan > 0);
        
        wellboreCtx.fillStyle = '#555';
        wellboreCtx.beginPath();
        wellboreCtx.moveTo(wellboreCenterX - 10, holeY - 15);
        wellboreCtx.lineTo(wellboreCenterX + 10, holeY - 15);
        wellboreCtx.lineTo(wellboreCenterX, holeY);
        wellboreCtx.closePath();
        wellboreCtx.fill();
        
        const actualDensity = getActualDensity(currentDepth);
        const predictedLookaheadDensity = predictDensity(currentDepth);
        const predictionY = ((currentDepth + LOOKAHEAD_DISTANCE) / MAX_DEPTH) * wellboreCanvas.height;
        
        drawInfoArrow(wellboreCtx, wellboreCanvas.width, holeY, `Actual: ${actualDensity.toFixed(1)}`, '#007bff');
        if (currentDepth + LOOKAHEAD_DISTANCE <= MAX_DEPTH) {
            drawInfoArrow(wellboreCtx, wellboreCanvas.width, predictionY, `Predicted: ${predictedLookaheadDensity.toFixed(1)}`, '#28a745');
        }
    }
    
    function drawInfoArrow(ctx, canvasWidth, y, text, color) {
        ctx.strokeStyle = color; ctx.fillStyle = color;
        ctx.font = 'bold 13px Arial'; ctx.textAlign = 'left';
        const textX = (canvasWidth / 2) + 20;
        const arrowEndX = textX - 5;
        const arrowStartX = arrowEndX - 20;
        ctx.fillText(text, textX, y + 4);
        ctx.beginPath();
        ctx.moveTo(arrowStartX, y); ctx.lineTo(arrowEndX, y);
        ctx.moveTo(arrowEndX, y); ctx.lineTo(arrowEndX - 6, y - 4);
        ctx.moveTo(arrowEndX, y); ctx.lineTo(arrowEndX - 6, y + 4);
        ctx.stroke();
    }
    
    // ----- GRAPH DRAWING (MODIFIED) -----
    function drawGraph() {
        graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
        
        const padding = 45;
        const chartWidth = graphCanvas.width - padding * 2;
        const chartHeight = graphCanvas.height - padding * 2;
        
        // MODIFIED: mapDepthToX now uses MAX_GRAPH_DEPTH for its scale
        const mapDepthToX = depth => padding + (depth / MAX_GRAPH_DEPTH) * chartWidth;
        const mapDensityToY = density => padding + chartHeight - ((density - minDensity) / (maxDensity - minDensity)) * chartHeight;

        // Draw Axes and Grid
        graphCtx.strokeStyle = '#ccc'; graphCtx.fillStyle = '#333'; graphCtx.font = '12px Arial';
        
        graphCtx.textAlign = 'right';
        for (let i = 0; i <= 5; i++) {
            const density = minDensity + (i/5) * (maxDensity - minDensity);
            const y = mapDensityToY(density);
            graphCtx.fillText(density.toFixed(0), padding - 5, y + 4);
            graphCtx.beginPath(); graphCtx.moveTo(padding, y); graphCtx.lineTo(padding + chartWidth, y); graphCtx.stroke();
        }
        
        graphCtx.textAlign = 'center';
        // MODIFIED: X-axis labels now go up to MAX_GRAPH_DEPTH
        for (let i = 0; i <= 6; i++) {
            const depth = (i/6) * MAX_GRAPH_DEPTH;
            const x = mapDepthToX(depth);
            graphCtx.fillText(depth.toFixed(0), x, padding + chartHeight + 15);
        }
        graphCtx.fillText("Depth (m)", padding + chartWidth/2, graphCanvas.height - 5);
        
        graphCtx.fillStyle = '#007bff'; graphCtx.fillRect(padding, 5, 10, 10);
        graphCtx.fillStyle = '#333'; graphCtx.textAlign = 'left';
        graphCtx.fillText('Actual Density', padding + 15, 14);
        graphCtx.fillStyle = '#28a745'; graphCtx.fillRect(padding + 120, 5, 10, 10);
        graphCtx.fillStyle = '#333';
        graphCtx.fillText('Predicted Density (at predicted depth)', padding + 135, 14);

        const lastIndex = findIndexForDepth(currentDepth);
        if (lastIndex < 1) return;

        // Actual Line (drawn up to currentDepth)
        graphCtx.strokeStyle = '#007bff'; graphCtx.lineWidth = 2;
        graphCtx.beginPath();
        graphCtx.moveTo(mapDepthToX(depthData[0]), mapDensityToY(rockData[0]));
        for (let i = 1; i <= lastIndex; i++) {
            graphCtx.lineTo(mapDepthToX(depthData[i]), mapDensityToY(rockData[i]));
        }
        graphCtx.stroke();

        // --- MODIFIED: Predicted Line plotting logic ---
        graphCtx.strokeStyle = '#28a745';
        graphCtx.lineWidth = 2;
        graphCtx.beginPath();
        let started = false;
        for (let i = 0; i <= lastIndex; i++) {
            const predictedValue = predictedData[i];
            if (predictedValue == null) continue;
            const depthOfPrediction = depthData[i] + LOOKAHEAD_DISTANCE;
            const x = mapDepthToX(depthOfPrediction);
            const y = mapDensityToY(predictedValue);
            if (!started) { graphCtx.moveTo(x, y); started = true; }
            else { graphCtx.lineTo(x, y); }
        }
        if (started) graphCtx.stroke();

        graphCtx.lineWidth = 1;
    }
    
    function renderAll() {
        drawWellbore();
        drawGraph();
    }

    // --- 3. SIMULATION LOGIC & EVENT HANDLING (Unchanged) ---
    function updateSimulation() {
        if (!isDrilling) return;
        currentDepth += DRILL_SPEED / 60;
        if (currentDepth >= MAX_DEPTH) {
            currentDepth = MAX_DEPTH;
            stopDrilling();
        }
        const drillTipY = (currentDepth / MAX_DEPTH) * wellboreCanvas.height;
        if (Math.random() > 0.5) { // Create particles less frequently
            particles.push({
                x: wellboreCanvas.width / 2, y: drillTipY,
                vx: (Math.random() - 0.5) * 3, vy: -Math.random() * 4 - 1,
                lifespan: Math.random() * 50 + 20, size: Math.random() * 2 + 1,
                color: `rgba(139, 69, 19, ${Math.random() * 0.5 + 0.5})`
            });
        }
        updateUI();
        renderAll();
        animationFrameId = requestAnimationFrame(updateSimulation);
    }

    function startDrilling() {
        if (isDrilling) return;
        isDrilling = true; playPauseBtn.textContent = 'Pause';
        animationFrameId = requestAnimationFrame(updateSimulation);
    }

    function stopDrilling() {
        if (!isDrilling) return;
        isDrilling = false; playPauseBtn.textContent = 'Play';
        cancelAnimationFrame(animationFrameId);
    }

    function updateUI() {
        depthSlider.value = currentDepth;
        infoDisplay.textContent = `Current Depth: ${currentDepth.toFixed(1)} m`;
    }

    function resizeCanvases() {
        const wellboreContainer = document.getElementById('wellbore-container');
        const graphContainer = document.getElementById('graph-container');
        wellboreCanvas.width = wellboreContainer.clientWidth - 24;
        wellboreCanvas.height = wellboreContainer.clientHeight - 40;
        graphCanvas.width = graphContainer.clientWidth - 24;
        graphCanvas.height = graphContainer.clientHeight - 40;
        renderAll();
    }

    // --- Event Listeners ---
    playPauseBtn.addEventListener('click', () => {
        if (isDrilling) {
            stopDrilling();
        } else {
            if (currentDepth >= MAX_DEPTH) {
                currentDepth = 0; particles = [];
            }
            startDrilling();
        }
    });
    depthSlider.addEventListener('input', () => {
        stopDrilling();
        currentDepth = parseFloat(depthSlider.value);
        updateUI();
        renderAll();
    });
    window.addEventListener('resize', resizeCanvases);

    // --- Initialization ---
    async function init() {
        await loadRockData();
        depthSlider.max = MAX_DEPTH;
        resizeCanvases();
        updateUI();
        console.log("Drilling simulation with predictive graph initialized.");
    }

    init();
</script>
</body>
</html>
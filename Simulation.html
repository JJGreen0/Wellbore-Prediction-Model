<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drilling Simulation with Predictive Graph</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            background-color: #f0f2f5;
            margin: 0;
            /* allow scrolling if controls overflow */
            overflow: auto;
        }
        #simulation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff;
            padding: 20px;
            /* remove extra margin so it fits full viewport */
            margin: 0;
            box-sizing: border-box;
            width: 98vw;
            height: 100vh;
        }
        h1 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            flex-shrink: 0;
        }
        #main-content {
            display: flex;
            flex: 1;            /* grow to fill available space */
            width: 100%;
            gap: 20px;
            box-sizing: border-box;
        }
        #wellbore-container, #graph-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            box-sizing: border-box;
        }
        #wellbore-container {
            flex: 0 0 320px;
        }
        #graph-container {
            flex-grow: 1;
        }
        h2 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: #444;
        }
        canvas {
            border: 2px solid #333;
        }
        #wellboreCanvas {
            background-color: #e8dcc5;
        }
        #graphCanvas {
            background-color: #fdfdfd;
        }
        #controls {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 400px;
            box-sizing: border-box;
        }
        #depth-slider {
            width: 80%;
        }
        button {
            padding: 8px 18px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        #info-display {
            font-size: 1em;
            font-weight: bold;
            color: #555;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
</head>
<body>

<div id="simulation-container">
    <h1>Drilling Simulation & Analysis</h1>
    <div id="main-content">
        <div id="wellbore-container">
            <h2>Wellbore View</h2>
            <canvas id="wellboreCanvas"></canvas>
        </div>
        <div id="graph-container">
            <h2 id="graph-title"></h2>
            <canvas id="graphCanvas"></canvas>
        </div>
    </div>
    <div id="controls">
        <div id="info-display">Current Depth: 0.0 m</div>
        <button id="play-pause-btn">Play</button>
        <label for="depth-slider">Manual Depth Control</label>
        <input type="range" id="depth-slider" min="0" max="3000" step="0.1" value="0">
    </div>
</div>

<script>
    // --- Configuration ---
    let MAX_DEPTH = 0;
    const LOOKAHEAD_DISTANCE = 50;
    let MAX_GRAPH_DEPTH = 0;
    const DRILL_SPEED = 50;
    const BASE_DENSITY = 2200;
    const TARGET = 'GR';               // <-- Change this to any feature name
    const DEPTHCOL = 'Unnamed: 0';
    const INPUT = 'WLC_MUD_LOG_INTERPOLATED.csv';

    // --- DOM Elements ---
    const graphTitle = document.getElementById('graph-title');
    const wellboreCanvas = document.getElementById('wellboreCanvas');
    const wellboreCtx = wellboreCanvas.getContext('2d');
    const graphCanvas = document.getElementById('graphCanvas');
    const graphCtx = graphCanvas.getContext('2d');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const depthSlider = document.getElementById('depth-slider');
    const infoDisplay = document.getElementById('info-display');

    // --- Data Variables ---
    let rockData = [];
    let predictedData = [];
    let minVal, maxVal;
    let currentDepth = 0;
    let isDrilling = false;
    let animationFrameId;
    let particles = [];
    let depthData = [];
    let startDepth = 0;

    // Offscreen static graph buffer
    let staticCanvas, staticCtx;

    // --- Load and parse CSV data ---
    async function loadRockData() {
        const response = await fetch(INPUT);
        const csvText = await response.text();
        const parsed = Papa.parse(csvText, { header: true, dynamicTyping: true }).data;
        startDepth = parseFloat(parsed[0][DEPTHCOL]) || 0;
        parsed.forEach(row => {
            const depth = parseFloat(row[DEPTHCOL]);
            const val = parseFloat(row[TARGET]);
            if (isFinite(depth) && isFinite(val)) {
                depthData.push(depth - startDepth);
                rockData.push(val);
            }
        });

        const predResp = await fetch('predictions_50m2.csv');
        const predText = await predResp.text();
        const predParsed = Papa.parse(predText, { header: true, dynamicTyping: true }).data;
        const predMap = new Map();
        predParsed.forEach(row => {
            const d = parseFloat(row[DEPTHCOL]);
            const p = parseFloat(row['pred_50m']);
            if (isFinite(d) && isFinite(p)) {
                predMap.set(d - startDepth, p);
            }
        });
        depthData.forEach(d => {
            const p = predMap.get(d);
            predictedData.push(p !== undefined ? p : null);
        });

        MAX_DEPTH = depthData[depthData.length - 1];
        MAX_GRAPH_DEPTH = MAX_DEPTH + LOOKAHEAD_DISTANCE;
        const allVals = rockData.concat(predictedData.filter(v => v !== null));
        minVal = Math.min(...allVals) - 5;
        maxVal = Math.max(...allVals) + 5;
    }

    // --- Utility Functions ---
    function findIndexForDepth(depth) {
        let low = 0, high = depthData.length - 1;
        while (low < high) {
            const mid = Math.floor((low + high) / 2);
            if (depthData[mid] < depth) low = mid + 1;
            else high = mid;
        }
        return low;
    }

    function predictValue(depth) {
        const idx = findIndexForDepth(depth);
        const pred = predictedData[idx];
        return (pred === null || pred === undefined)
            ? rockData[idx]
            : pred;
    }

    // --- Pre-build static graph ---
    function buildStaticGraph() {
        staticCanvas = document.createElement('canvas');
        staticCanvas.width = graphCanvas.width;
        staticCanvas.height = graphCanvas.height;
        staticCtx = staticCanvas.getContext('2d');

        const pad = 45;
        const w = graphCanvas.width - pad * 2;
        const h = graphCanvas.height - pad * 2;
        const mapX = d => pad + (d / MAX_GRAPH_DEPTH) * w;
        const mapY = v => pad + h - ((v - minVal) / (maxVal - minVal)) * h;

        // Axes and grid
        staticCtx.strokeStyle = '#ccc';
        staticCtx.fillStyle = '#333';
        staticCtx.font = '12px Arial';
        staticCtx.textAlign = 'right';
        for (let i = 0; i <= 5; i++) {
            const v = minVal + (i / 5) * (maxVal - minVal);
            const y = mapY(v);
            staticCtx.fillText(v.toFixed(0), pad - 5, y + 4);
            staticCtx.beginPath();
            staticCtx.moveTo(pad, y);
            staticCtx.lineTo(pad + w, y);
            staticCtx.stroke();
        }
        staticCtx.textAlign = 'center';
        for (let i = 0; i <= 6; i++) {
            const d = (i / 6) * MAX_GRAPH_DEPTH;
            const x = mapX(d);
            staticCtx.fillText(d.toFixed(0), x, pad + h + 15);
        }
        staticCtx.fillText('Depth (m)', pad + w / 2, graphCanvas.height - 5);

        // Legend
        staticCtx.fillStyle = '#007bff'; staticCtx.fillRect(pad, 5, 10, 10);
        staticCtx.fillStyle = '#333'; staticCtx.textAlign = 'left';
        staticCtx.fillText(`Actual ${TARGET}`, pad + 15, 14);
        staticCtx.fillStyle = '#28a745'; staticCtx.fillRect(pad + 120, 5, 10, 10);
        staticCtx.fillStyle = '#333';
        staticCtx.fillText(`Predicted ${TARGET}`, pad + 135, 14);

        // Actual curve
        staticCtx.strokeStyle = '#007bff'; staticCtx.lineWidth = 2;
        staticCtx.beginPath();
        staticCtx.moveTo(mapX(depthData[0]), mapY(rockData[0]));
        for (let i = 1; i < depthData.length; i++) {
            staticCtx.lineTo(mapX(depthData[i]), mapY(rockData[i]));
        }
        staticCtx.stroke();

        // Predicted curve
        staticCtx.strokeStyle = '#28a745'; staticCtx.beginPath();
        let started = false;
        for (let i = 0; i < depthData.length; i++) {
            const p = predictedData[i];
            if (p == null) continue;
            const x = mapX(depthData[i] + LOOKAHEAD_DISTANCE);
            const y = mapY(p);
            if (!started) { staticCtx.moveTo(x, y); started = true; } else { staticCtx.lineTo(x, y); }
        }
        if (started) staticCtx.stroke();
        staticCtx.lineWidth = 1;
    }

    // --- Drawing Functions ---
    function drawInfoArrow(ctx, w, y, text, color) {
        ctx.strokeStyle = color; ctx.fillStyle = color;
        ctx.font = 'bold 13px Arial'; ctx.textAlign = 'left';
        const textX = (w / 2) + 20;
        const endX = textX - 5;
        const startX = endX - 20;
        ctx.fillText(text, textX, y + 4);
        ctx.beginPath();
        ctx.moveTo(startX, y); ctx.lineTo(endX, y);
        ctx.moveTo(endX, y); ctx.lineTo(endX - 6, y - 4);
        ctx.moveTo(endX, y); ctx.lineTo(endX - 6, y + 4);
        ctx.stroke();
    }

    function drawWellbore() {
        wellboreCtx.clearRect(0, 0, wellboreCanvas.width, wellboreCanvas.height);
        const holeY = (currentDepth / MAX_DEPTH) * wellboreCanvas.height;
        const centerX = wellboreCanvas.width / 2;
        wellboreCtx.fillStyle = '#3a352d'; wellboreCtx.fillRect(centerX - 11, 0, 22, holeY);
        particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.lifespan--; wellboreCtx.fillStyle = p.color; wellboreCtx.globalAlpha = p.lifespan/50; wellboreCtx.fillRect(p.x, p.y, p.size, p.size); });
        wellboreCtx.globalAlpha = 1.0; particles = particles.filter(p => p.lifespan > 0);
        wellboreCtx.fillStyle = '#555'; wellboreCtx.beginPath(); wellboreCtx.moveTo(centerX - 10, holeY - 15); wellboreCtx.lineTo(centerX + 10, holeY - 15); wellboreCtx.lineTo(centerX, holeY); wellboreCtx.closePath(); wellboreCtx.fill();
        const actual = rockData[findIndexForDepth(currentDepth)];
        const predicted = predictValue(currentDepth + LOOKAHEAD_DISTANCE);
        drawInfoArrow(wellboreCtx, wellboreCanvas.width, holeY, `Actual ${TARGET}: ${actual.toFixed(1)}`, '#007bff');
        if (currentDepth + LOOKAHEAD_DISTANCE <= MAX_DEPTH) {
            const py = ((currentDepth + LOOKAHEAD_DISTANCE)/MAX_DEPTH)*wellboreCanvas.height;
            drawInfoArrow(wellboreCtx, wellboreCanvas.width, py, `Predicted ${TARGET}: ${predicted.toFixed(1)}`, '#28a745');
        }
    }

    function drawGraph() {
        graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
        graphCtx.drawImage(staticCanvas, 0, 0);
        const pad = 45;
        const chartW = graphCanvas.width - pad * 2;
        const x = pad + (currentDepth / MAX_GRAPH_DEPTH) * chartW;
        graphCtx.strokeStyle = '#ff6600'; graphCtx.lineWidth = 1.5;
        graphCtx.beginPath(); graphCtx.moveTo(x, pad); graphCtx.lineTo(x, graphCanvas.height - pad); graphCtx.stroke();
    }

    // --- Simulation & Event Handling ---
    function updateSimulation() {
        if (!isDrilling) return;
        currentDepth += DRILL_SPEED / 60;
        if (currentDepth >= MAX_DEPTH) { currentDepth = MAX_DEPTH; stopDrilling(); }
        if (Math.random() > 0.5) { const y = (currentDepth / MAX_DEPTH) * wellboreCanvas.height; particles.push({ x: wellboreCanvas.width/2, y, vx: (Math.random()-0.5)*3, vy: -Math.random()*4-1, lifespan: Math.random()*50+20, size: Math.random()*2+1, color: `rgba(139,69,19,${Math.random()*0.5+0.5})` }); }
        depthSlider.value = currentDepth; infoDisplay.textContent = `Current Depth: ${currentDepth.toFixed(1)} m`;
        drawWellbore(); drawGraph();
        animationFrameId = requestAnimationFrame(updateSimulation);
    }

    function startDrilling() { isDrilling = true; playPauseBtn.textContent = 'Pause'; animationFrameId = requestAnimationFrame(updateSimulation); }
    function stopDrilling() { isDrilling = false; playPauseBtn.textContent = 'Play'; cancelAnimationFrame(animationFrameId); }

    playPauseBtn.addEventListener('click', () => { if (isDrilling) stopDrilling(); else { if (currentDepth >= MAX_DEPTH) { currentDepth = 0; particles = []; } startDrilling(); }});
    depthSlider.addEventListener('input', () => { stopDrilling(); currentDepth = parseFloat(depthSlider.value); infoDisplay.textContent = `Current Depth: ${currentDepth.toFixed(1)} m`; drawWellbore(); drawGraph(); });
    window.addEventListener('resize', () => { const wc=document.getElementById('wellbore-container'), gc=document.getElementById('graph-container'); wellboreCanvas.width=wc.clientWidth-24; wellboreCanvas.height=wc.clientHeight-40; graphCanvas.width=gc.clientWidth-24; graphCanvas.height=gc.clientHeight-40; buildStaticGraph(); drawWellbore(); drawGraph(); });

    // --- Initialization ---
    async function init() {
        graphTitle.textContent = `${TARGET} vs Depth`;
        await loadRockData();
        depthSlider.max = MAX_DEPTH;
        const wc=document.getElementById('wellbore-container'), gc=document.getElementById('graph-container');
        wellboreCanvas.width=wc.clientWidth-24; wellboreCanvas.height=wc.clientHeight-40;
        graphCanvas.width=gc.clientWidth-24; graphCanvas.height=gc.clientHeight-40;
        buildStaticGraph();
        drawWellbore(); drawGraph();
    }
    init();
</script>
</body>
</html>
